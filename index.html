<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Script Rehearsal Tool</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }
    .header h1 { font-size: 32px; margin-bottom: 10px; }
    .header p { opacity: 0.9; font-size: 16px; }
    .content { padding: 30px; }

    .upload-section {
      text-align: center;
      padding: 40px;
      background: #f8f9fa;
      border-radius: 12px;
      margin-bottom: 20px;
    }
    .upload-section input[type="file"] { display: none; }
    .upload-btn {
      background: #667eea;
      color: white;
      padding: 15px 40px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
      display: inline-block;
    }
    .upload-btn:hover { background:#5568d3; transform: translateY(-2px); }

    .hidden { display: none; }

    .status {
      text-align: center;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      font-weight: 500;
    }
    .status.ready { background: #e3f2fd; color: #1976d2; }
    .status.playing { background: #fff3e0; color: #f57c00; }
    .status.complete { background: #e8f5e9; color: #388e3c; }
    .status.error { background: #ffebee; color: #d32f2f; }

    .speed-control {
      text-align: center;
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .speed-control label { font-weight: 500; margin-right: 10px; }
    .speed-control input[type="range"] { width: 200px; vertical-align: middle; }
    .speed-control span { margin-left: 10px; font-weight: bold; color: #667eea; }

    .selection-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 30px;
    }
    @media (max-width: 768px) {
      .selection-container { grid-template-columns: 1fr; }
    }
    .selection-box {
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 20px;
      background: #fafafa;
    }
    .selection-box h3 {
      color: #333;
      margin-bottom: 15px;
      font-size: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .button-group { display:flex; gap:10px; }
    .small-btn {
      background: #e0e0e0;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .small-btn:hover:not(:disabled) { background:#d0d0d0; }
    .small-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .checkbox-container {
      max-height: 400px;
      overflow-y: auto;
      padding: 10px;
      background: white;
      border-radius: 8px;
    }
    .checkbox-item {
      padding: 10px;
      border-bottom: 1px solid #f0f0f0;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .checkbox-item:last-child { border-bottom: none; }
    .checkbox-item input[type="checkbox"] { width: 18px; height: 18px; cursor:pointer; }
    .checkbox-item label { cursor:pointer; flex:1; font-size: 14px; }

    .controls { text-align:center; margin-bottom: 30px; }
    .control-btn {
      padding: 15px 40px;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      margin: 0 10px;
      transition: all 0.3s;
      font-weight: 600;
    }
    .play-btn { background:#4CAF50; color:white; }
    .play-btn:hover:not(:disabled) { background:#45a049; transform: translateY(-2px); }
    .stop-btn { background:#f44336; color:white; }
    .stop-btn:hover:not(:disabled) { background:#da190b; transform: translateY(-2px); }
    .control-btn:disabled { opacity:0.5; cursor:not-allowed; }

    .pause-btn { background:#ff9800; color:white; }
    .pause-btn:hover:not(:disabled) { background:#fb8c00; transform: translateY(-2px); }

    .timeline {
      margin: 0 auto 20px;
      max-width: 500px;
      text-align: center;
    }
    .timeline input[type="range"] {
      width: 100%;
    }

    .line-display {
      background: #f5f5f5;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      padding: 25px;
      min-height: 120px;
      font-size: 16px;
      line-height: 1.6;
    }
    .line-display .character {
      font-weight: bold;
      color: #667eea;
      font-size: 18px;
      margin-bottom: 10px;
    }
    .line-display .line-text { color:#333; }

    /* Voice Picker */
    .voice-section {
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      margin-bottom: 20px;
    }
    .voice-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:white;
      padding: 10px 12px;
      border-radius: 8px;
      margin-bottom: 10px;
      border: 1px solid #eee;
    }
    .voice-row .name { font-weight: 700; color:#333; }
    .voice-row label { margin-left: 10px; font-size: 14px; cursor:pointer; }
    .voice-row select {
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      font-size: 13px;
    }

    .voice-preview {
      margin: 10px 0 18px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .voice-preview button {
      font-size: 12px;
    }

    .hint { color:#666; margin-top:10px; font-size: 13px; }

    /* Download JSON emphasis */
    .download-box {
      margin-top: 16px;
      padding: 16px 18px;
      border-radius: 12px;
      border: 2px dashed #667eea;
      background: #eef2ff;
    }
    .download-btn {
      background: white;
      color: #667eea;
      border: 2px solid #667eea;
      padding: 10px 26px;
      border-radius: 999px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(102,126,234,0.25);
      transition: all 0.25s ease;
    }
    .download-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      box-shadow: none;
    }
    .download-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      background: #667eea;
      color: white;
    }
    .download-label-strong {
      font-weight: 700;
      color: #4338ca;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>üé≠ Script Rehearsal Tool</h1>
      <p>Upload a script PDF (slow) or JSON file (fast) ‚Üí choose voices ‚Üí rehearse</p>
    </div>

    <div class="content">
      <!-- Upload -->
      <div id="uploadSection" class="upload-section">
        <h2 style="margin-bottom: 14px;">Upload Your Script</h2>
        <p style="margin-bottom: 18px; color:#666;">
          Upload a <b>PDF</b> (we‚Äôll parse it) or upload a <b>JSON file</b> directly for faster loading.
        </p>
        <input type="file" id="fileInput" accept=".pdf,.json"/>
        <label for="fileInput" class="upload-btn">Choose PDF or JSON</label>
        <p id="fileName" style="margin-top: 15px; color:#666;"></p>
      </div>

      <!-- Voice selection -->
      <div id="voiceSection" class="voice-section hidden">
        <h2 style="margin-bottom: 10px;">Choose voices</h2>
        <p style="margin-bottom: 15px; color:#666;">
          Preview the available voices, then pick one from the dropdown for each character.
        </p>
        <!-- Download JSON (recommended) -->
        <div id="downloadJsonBoxVoice" class="download-box" style="margin: 10px 0 16px;">
          <div class="download-label-strong" style="margin-bottom:8px;">Save this script for next time</div>
          <button id="downloadJsonBtn" class="download-btn" type="button">
            ‚¨á Download script_data.json
          </button>
          <div id="downloadJsonHint" class="hint" style="margin-top:8px;">
            Upload a script first to enable download.
          </div>
        </div>

        <div>
          <div class="download-label-strong" style="margin-bottom:6px;">Preview device voices</div>
          <div id="voicePreviewList" class="voice-preview"></div>
        </div>

        <div id="voiceList" style="margin-top: 12px;"></div>
        <div style="margin-top: 15px; text-align:center;">
          <button class="control-btn play-btn" type="button" onclick="confirmVoices()">Continue</button>
        </div>
      </div>

      <!-- Main rehearsal UI -->
      <div id="mainSection" class="hidden">
        <div class="speed-control">
          <label for="speedSlider">Speech Speed:</label>
          <input type="range" id="speedSlider" min="0.5" max="2" step="0.1" value="1.0"/>
          <span id="speedValue">1.0x</span>
        </div>

        <div class="selection-container">
          <div class="selection-box">
            <h3>
              Select Scenes
              <div class="button-group">
                <button class="small-btn" type="button" onclick="selectAllScenes()">All</button>
                <button class="small-btn" type="button" onclick="deselectAllScenes()">None</button>
              </div>
            </h3>
            <div class="checkbox-container" id="sceneCheckboxes"></div>
          </div>

          <div class="selection-box">
            <h3>
              Characters to Speak
              <div class="button-group">
                <button class="small-btn" type="button" onclick="selectAllCharacters()">All</button>
                <button class="small-btn" type="button" onclick="deselectAllCharacters()">None</button>
              </div>
            </h3>
            <div class="checkbox-container" id="characterCheckboxes"></div>
          </div>
        </div>

        <div class="controls">
          <button class="control-btn play-btn" id="playBtn" type="button" onclick="startRehearsal()">‚ñ∂ Start Rehearsal</button>
          <button class="control-btn pause-btn" id="pauseBtn" type="button" onclick="togglePause()" disabled>‚è∏ Pause</button>
          <button class="control-btn stop-btn" id="stopBtn" type="button" onclick="stopRehearsal()" disabled>‚èπ Stop</button>
        </div>

        <div class="timeline">
          <input type="range" id="timelineSlider" min="0" value="0" step="1" disabled />
          <div class="hint" id="timelineHint">Use the slider to jump to a specific point in your selected scenes.</div>
        </div>

        <div class="status ready" id="status">Ready to rehearse</div>

        <div class="line-display" id="lineDisplay">
          <div style="text-align:center; color:#999;">Select scenes and press Start to begin</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== Config ======
    const API_BASE = "https://scriptv2.onrender.com";
    window.API_BASE = API_BASE;
    const backendEl = document.getElementById("backendUrl");
    if (backendEl) {
      backendEl.textContent = API_BASE;
    }

    // ====== App State ======
    let scriptData = null;
    let charactersList = [];
    let characterVoiceId = {}; // { "SELBY": "voiceURI-or-name", ... }
    let isPlaying = false;
    let isPaused = false;
    const speechSynthesis = window.speechSynthesis;
    let currentUtterance = null;
    let availableVoices = [];
    let playbackTimeline = []; // flattened list of lines across selected scenes
    let currentLineIndex = 0;

    // ====== Voices: load asynchronously (browser-dependent) ======
    function loadVoices() {
      availableVoices = speechSynthesis.getVoices();
      const voiceSection = document.getElementById('voiceSection');
      if (voiceSection && !voiceSection.classList.contains('hidden')) {
        renderVoicePicker();
      }
    }
    loadVoices();
    if (speechSynthesis.onvoiceschanged !== undefined) {
      speechSynthesis.onvoiceschanged = loadVoices;
    }

    // ====== Helpers: escaping ======
    function escapeHtml(str) {
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }
    function escapeAttr(str) {
      // for IDs only (safe CSS-ish)
      return String(str).replace(/[^a-zA-Z0-9_-]/g, "_");
    }
    function attrValue(str) {
      // for value="..." attributes: DO NOT change characters, only escape HTML
      return escapeHtml(str);
    }

    // ====== Download button state ======
    function updateDownloadButton() {
      const btn = document.getElementById("downloadJsonBtn");
      const hint = document.getElementById("downloadJsonHint");
      const voiceBox = document.getElementById("downloadJsonBoxVoice");
      const ready = !!scriptData;

      if (btn) {
        btn.disabled = !ready;
        btn.style.opacity = ready ? "1" : "0.5";
      }
      if (hint) {
        hint.textContent = ready
          ? "Downloads JSON (upload it next time for faster rehearsal)."
          : "Upload a PDF or JSON file first to enable download.";
      }
      if (voiceBox) {
        // Only show the JSON download box on the voice screen once script data is ready.
        voiceBox.style.display = ready ? "block" : "none";
      }
    }

    const downloadBtnEl = document.getElementById("downloadJsonBtn");
    if (downloadBtnEl) {
      downloadBtnEl.addEventListener("click", () => {
        if (!scriptData) return;
        downloadCurrentJson();
      });
    }

    // ====== Upload handler: accept PDF or JSON ======
    document.getElementById('fileInput').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const name = file.name.toLowerCase();

      // reset state
      scriptData = null;
      charactersList = [];
      updateDownloadButton();

      document.getElementById('fileName').textContent = `Loading ${file.name}...`;

      // JSON path: no backend needed
      if (name.endsWith(".json")) {
        updateStatus("Loading JSON‚Ä¶", "playing");

        const reader = new FileReader();
        reader.onload = function(evt) {
          try {
            scriptData = JSON.parse(evt.target.result);
            charactersList = extractCharactersFromScriptData(scriptData);

            document.getElementById('fileName').textContent = `‚úì Loaded ${file.name}`;
            updateStatus("JSON loaded. Choose voices.", "ready");
            updateDownloadButton();

            showVoicePicker(charactersList);
          } catch (err) {
            updateStatus("Error parsing JSON file. Please upload a valid script_data.json.", "error");
            document.getElementById('fileName').textContent = `‚úó Invalid JSON`;
          }
        };
        reader.readAsText(file);
        return;
      }

      // PDF path: backend required
      if (name.endsWith(".pdf")) {
        updateStatus("Uploading PDF‚Ä¶", "playing");

        const formData = new FormData();
        formData.append("file", file);

        try {
          const res = await fetch(`${API_BASE}/api/parse-pdf`, { method: "POST", body: formData });
          const data = await res.json();

          if (!data.ok) {
            updateStatus(data.message || "Could not parse PDF.", "error");
            document.getElementById('fileName').textContent = `‚úó ${data.message || "Error"}`;
            return;
          }

          scriptData = data.script_data;
          charactersList = data.characters || extractCharactersFromScriptData(scriptData);

          document.getElementById('fileName').textContent = `‚úì Parsed ${file.name} (${data.total_lines || ""} lines)`;

          updateDownloadButton();
          const downloadJsonHintEl = document.getElementById("downloadJsonHint");
          if (downloadJsonHintEl) {
            downloadJsonHintEl.innerHTML = " <b>Tip:</b> Download the JSON now so next time you can upload it instantly (skip PDF parsing).";
          }

          updateStatus("PDF parsed. Choose voices.", "ready");

          showVoicePicker(charactersList);
        } catch (err) {
          updateStatus("Server error. Backend/CORS issue.", "error");
          document.getElementById('fileName').textContent = "‚úó Server error";
        }
        return;
      }

      updateStatus("Please upload a .pdf or .json file.", "error");
      document.getElementById('fileName').textContent = "‚úó Unsupported file type";
    });

    // ====== Speed control ======
    document.getElementById('speedSlider').addEventListener('input', function(e) {
      document.getElementById('speedValue').textContent = e.target.value + 'x';
    });

    // ====== Screen transitions ======
    function showVoicePicker(characters) {
      document.getElementById('uploadSection').classList.add('hidden');
      document.getElementById('mainSection').classList.add('hidden');
      document.getElementById('voiceSection').classList.remove('hidden');

      renderVoicePicker();
      updateStatus("Choose voices, then continue.", "ready");
    }

    function renderVoicePicker() {
      const previewEl = document.getElementById("voicePreviewList");
      const list = document.getElementById("voiceList");
      if (!previewEl || !list) return;

      const usableVoices = getUsableVoices();
      previewEl.innerHTML = "";
      list.innerHTML = "";

      if (usableVoices.length === 0) {
        previewEl.textContent = "No speech voices available in this browser.";
        return;
      }

      // Voice preview buttons
      usableVoices.forEach((voice, idx) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "small-btn";
        const label = voice.name || `Voice ${idx + 1}`;
        btn.textContent = `Voice ${idx + 1}: ${label}`;
        btn.addEventListener("click", () => {
          playPreviewVoice(voice);
        });
        previewEl.appendChild(btn);
      });

      // Default assignments if not set: cycle through the usable voices
      charactersList.forEach((c, index) => {
        if (!characterVoiceId[c]) {
          const v = usableVoices[index % usableVoices.length];
          characterVoiceId[c] = v._scriptVoiceId;
        }
      });

      // Per‚Äëcharacter dropdowns
      charactersList.forEach(c => {
        const row = document.createElement("div");
        row.className = "voice-row";
        const selectId = `voice-select-${escapeAttr(c)}`;

        const optionsHtml = usableVoices.map((voice, idx) => {
          const id = voice._scriptVoiceId;
          const isSelected = characterVoiceId[c] === id;
          const label = voice.name || `Voice ${idx + 1}`;
          return `<option value="${escapeAttr(id)}" ${isSelected ? "selected" : ""}>Voice ${idx + 1}: ${escapeHtml(label)}</option>`;
        }).join("");

        row.innerHTML = `
          <div class="name">${escapeHtml(c)}</div>
          <div>
            <select id="${selectId}">
              ${optionsHtml}
            </select>
          </div>
        `;

        const selectEl = row.querySelector("select");
        if (selectEl) {
          selectEl.addEventListener("change", (e) => {
            characterVoiceId[c] = e.target.value;
          });
        }

        list.appendChild(row);
      });
    }

    function confirmVoices() {
      document.getElementById('voiceSection').classList.add('hidden');
      document.getElementById('mainSection').classList.remove('hidden');

      populateScriptUI();
      updateStatus("Ready to rehearse.", "ready");
    }

    // ====== Build scene + character checkboxes ======
    function populateScriptUI() {
      if (!scriptData || !scriptData.scenes) {
        updateStatus("No script data loaded.", "error");
        return;
      }

      // Scenes
      const sceneContainer = document.getElementById('sceneCheckboxes');
      sceneContainer.innerHTML = '';
      scriptData.scenes.forEach(scene => {
        const sceneNum = String(scene.scene_number ?? "");
        const div = document.createElement('div');
        div.className = 'checkbox-item';
        div.innerHTML = `
          <input type="checkbox" id="scene-${escapeAttr(sceneNum)}" value="${attrValue(sceneNum)}">
          <label for="scene-${escapeAttr(sceneNum)}">Scene ${escapeHtml(sceneNum)}: ${escapeHtml(scene.scene_title ?? "")}</label>
        `;
        sceneContainer.appendChild(div);
      });

      // Characters
      const characterSet = new Set();
      scriptData.scenes.forEach(scene => {
        (scene.lines || []).forEach(line => {
          if (line.character) characterSet.add(String(line.character));
        });
      });

      const allCharacters = Array.from(characterSet).sort();

      const characterContainer = document.getElementById('characterCheckboxes');
      characterContainer.innerHTML = '';

      allCharacters.forEach(character => {
        const div = document.createElement('div');
        div.className = 'checkbox-item';
        const safe = escapeAttr(character);
        div.innerHTML = `
          <input type="checkbox" id="char-${safe}" value="${attrValue(character)}" checked>
          <label for="char-${safe}">${escapeHtml(character)}</label>
        `;
        characterContainer.appendChild(div);
      });
    }

    // ====== Select all/none ======
    function selectAllScenes() {
      document.querySelectorAll('#sceneCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = true);
    }
    function deselectAllScenes() {
      document.querySelectorAll('#sceneCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = false);
    }
    function selectAllCharacters() {
      document.querySelectorAll('#characterCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = true);
    }
    function deselectAllCharacters() {
      document.querySelectorAll('#characterCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = false);
    }

    // ====== Rehearsal loop ======
    async function startRehearsal() {
      const selectedScenes = Array.from(document.querySelectorAll('#sceneCheckboxes input:checked')).map(cb => cb.value);
      if (selectedScenes.length === 0) {
        updateStatus('Please select at least one scene', 'error');
        return;
      }

      const selectedCharacters = new Set(
        Array.from(document.querySelectorAll('#characterCheckboxes input:checked')).map(cb => cb.value)
      );

      // Build flat playback timeline for slider + seeking
      const scenesToPlay = scriptData.scenes.filter(scene => selectedScenes.includes(String(scene.scene_number)));
      playbackTimeline = [];
      scenesToPlay.forEach(scene => {
        (scene.lines || []).forEach(lineData => {
          playbackTimeline.push({
            sceneNumber: String(scene.scene_number ?? ""),
            sceneTitle: String(scene.scene_title ?? ""),
            character: String(lineData.character ?? ""),
            text: String(lineData.line ?? "")
          });
        });
      });

      if (playbackTimeline.length === 0) {
        updateStatus('No lines found in selected scenes.', 'error');
        return;
      }

      const timelineSlider = document.getElementById('timelineSlider');
      timelineSlider.max = String(Math.max(playbackTimeline.length - 1, 0));
      timelineSlider.disabled = false;

      // allow user to pre‚Äëselect a starting point before pressing play
      currentLineIndex = Number(timelineSlider.value) || 0;
      currentLineIndex = Math.min(Math.max(currentLineIndex, 0), playbackTimeline.length - 1);

      isPlaying = true;
      isPaused = false;
      document.getElementById('playBtn').disabled = true;
      document.getElementById('pauseBtn').disabled = false;
      document.getElementById('pauseBtn').textContent = '‚è∏ Pause';
      document.getElementById('stopBtn').disabled = false;

      const totalLines = playbackTimeline.length;

      while (isPlaying && currentLineIndex < totalLines) {
        const startIndex = currentLineIndex;
        const item = playbackTimeline[startIndex];
        const prevSceneNumber = startIndex > 0 ? playbackTimeline[startIndex - 1].sceneNumber : null;

        // If we jumped scenes or are at the very first line, show a scene header
        if (startIndex === 0 || item.sceneNumber !== prevSceneNumber) {
          updateLineDisplay(`Scene ${item.sceneNumber}`, item.sceneTitle);
          updateStatus(`Starting Scene ${item.sceneNumber}`, 'playing');
          await sleep(1500);
          if (!isPlaying) break;
        }

        // Wait here while paused (between lines)
        while (isPlaying && isPaused) {
          await sleep(200);
        }
        if (!isPlaying) break;

        updateLineDisplay(item.character, item.text);
        updateStatus(`Scene ${item.sceneNumber} | Line ${startIndex + 1}/${totalLines}`, 'playing');
        timelineSlider.value = String(startIndex);

        if (selectedCharacters.has(item.character)) {
          await speakLine(item.text, item.character);
        } else {
          const words = item.text.split(/\s+/).filter(Boolean).length;
          const pauseTime = Math.max(Math.round((words / 3.0) * 1000), 1000);
          await sleep(pauseTime);
        }

        if (!isPlaying) break;

        // If the user has not moved the slider to a new position, advance sequentially.
        if (currentLineIndex === startIndex) {
          currentLineIndex = startIndex + 1;
        }
      }

      if (isPlaying) updateStatus('Rehearsal complete!', 'complete');
      else updateStatus('Rehearsal stopped', 'ready');

      stopRehearsal();
    }

    function stopRehearsal() {
      isPlaying = false;
      isPaused = false;
      document.getElementById('playBtn').disabled = false;
      const pauseBtn = document.getElementById('pauseBtn');
      if (pauseBtn) {
        pauseBtn.disabled = true;
        pauseBtn.textContent = '‚è∏ Pause';
      }
      document.getElementById('stopBtn').disabled = true;

      if (currentUtterance) {
        speechSynthesis.cancel();
        currentUtterance = null;
      }
    }

    function togglePause() {
      if (!isPlaying) return;
      const btn = document.getElementById('pauseBtn');
      if (!btn) return;

      if (!isPaused) {
        isPaused = true;
        try { speechSynthesis.pause(); } catch (e) {}
        btn.textContent = '‚ñ∂ Resume';
        updateStatus('Paused', 'playing');
      } else {
        isPaused = false;
        try { speechSynthesis.resume(); } catch (e) {}
        btn.textContent = '‚è∏ Pause';
      }
    }

    // ====== Pick voice ======
    function getUsableVoices() {
      const voices = (availableVoices && availableVoices.length)
        ? availableVoices
        : speechSynthesis.getVoices() || [];

      // Ensure each voice has a stable internal ID we can use everywhere
      voices.forEach((v, idx) => {
        if (!v._scriptVoiceId) {
          v._scriptVoiceId = v.voiceURI || v.name || `voice-${idx}`;
        }
      });

      const en = voices.filter(v => (v.lang || "").toLowerCase().startsWith("en"));
      return en.length ? en : voices;
    }

    function playPreviewVoice(voice) {
      if (!voice) return;
      const utterance = new SpeechSynthesisUtterance("Hi, how are you doing?");
      utterance.voice = voice;
      utterance.rate = 1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(utterance);
    }

    function pickVoiceForGender(gender) {
      const voices = (availableVoices && availableVoices.length) ? availableVoices : speechSynthesis.getVoices();
      if (!voices || voices.length === 0) return null;

      const en = voices.filter(v => (v.lang || "").toLowerCase().startsWith("en"));
      const pool = en.length ? en : voices;

      // Try to infer groupings based on common name patterns
      const femaleCandidates = pool.filter(v =>
        /(female|woman|girl|susan|victoria|samantha|allison|amy)/i.test(v.name || "")
      );
      const maleCandidates = pool.filter(v =>
        /(male|man|boy|alex|daniel|david|fred|george)/i.test(v.name || "")
      );
      const neutralCandidates = pool.filter(v =>
        !femaleCandidates.includes(v) && !maleCandidates.includes(v)
      );

      if (gender === "female") {
        return femaleCandidates[0] || pool[0] || voices[0];
      }
      if (gender === "male") {
        return maleCandidates[0] || pool[1] || pool[0] || voices[0];
      }
      // non-binary: prefer something that isn't strongly male/female-labelled,
      // otherwise just pick a third distinct option if available.
      return neutralCandidates[0] || pool[2] || pool[1] || pool[0] || voices[0];
    }

    function speakLine(text, character) {
      return new Promise((resolve) => {
        if (!isPlaying) return resolve();

        currentUtterance = new SpeechSynthesisUtterance(text || "");
        const speed = parseFloat(document.getElementById('speedSlider').value);
        currentUtterance.rate = speed;

        const usableVoices = getUsableVoices();
        let voice = null;
        if (usableVoices.length) {
          const id = characterVoiceId[character];
          if (id) {
            voice = usableVoices.find(v => v._scriptVoiceId === id) || null;
          }
          if (!voice) {
            voice = usableVoices[0];
          }
        } else {
          voice = pickVoiceForGender("female");
        }

        if (voice) currentUtterance.voice = voice;

        currentUtterance.onend = () => { currentUtterance = null; resolve(); };
        currentUtterance.onerror = () => { currentUtterance = null; resolve(); };

        speechSynthesis.speak(currentUtterance);
      });
    }

    // ====== Sleep ======
    function sleep(ms) {
      return new Promise(resolve => {
        let remaining = ms;
        const step = 100;

        function tick() {
          if (!isPlaying) return resolve();
          if (isPaused) {
            setTimeout(tick, step);
            return;
          }
          if (remaining <= 0) return resolve();
          remaining -= step;
          setTimeout(tick, step);
        }

        tick();
      });
    }

    function updateLineDisplay(character, line) {
      const display = document.getElementById('lineDisplay');
      display.innerHTML = `
        <div class="character">${escapeHtml(character || "")}</div>
        <div class="line-text">${escapeHtml(line || "")}</div>
      `;
    }

    function updateStatus(message, type) {
      const status = document.getElementById('status');
      if (!status) return;
      status.textContent = message;
      status.className = `status ${type}`;
    }

    // ====== JSON helpers ======
    function extractCharactersFromScriptData(data) {
      const s = new Set();
      (data.scenes || []).forEach(scene => {
        (scene.lines || []).forEach(line => {
          if (line.character) s.add(String(line.character));
        });
      });
      return Array.from(s).sort();
    }

    function downloadCurrentJson() {
      if (!scriptData) return;

      const blob = new Blob([JSON.stringify(scriptData, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "script_data.json";
      document.body.appendChild(a);
      a.click();
      a.remove();

      URL.revokeObjectURL(url);
    }

    // ====== Timeline slider behaviour ======
    const timelineSliderEl = document.getElementById('timelineSlider');
    if (timelineSliderEl) {
      timelineSliderEl.addEventListener('input', (e) => {
        if (!playbackTimeline || playbackTimeline.length === 0) return;
        const idx = Number(e.target.value) || 0;
        currentLineIndex = Math.min(Math.max(idx, 0), playbackTimeline.length - 1);

        // If we're not currently playing, update the preview text immediately
        if (!isPlaying) {
          const item = playbackTimeline[currentLineIndex];
          if (item) {
            updateLineDisplay(item.character, item.text);
          }
        }
      });
    }

    // init
    updateDownloadButton();
  </script>
</body>
</html>